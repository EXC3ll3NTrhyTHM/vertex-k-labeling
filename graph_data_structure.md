# Graph Representation

This document outlines the data structures used to represent graphs and their properties within this project.

## 1. Graph Structure: Adjacency List

The fundamental structure of a graph is represented by an **adjacency list**. This is implemented as a Python dictionary (`collections.defaultdict(list)`) where each key is a vertex, and the value is a list of its adjacent vertices.

### Adjacency List Examples

Here are examples for each type of graph generated in `src/graph_generator.py`.

#### Ladder Graph

Generated by `generate_ladder_graph(n)`. Vertices are represented as tuples `(row, column)`.

**Example for `n=2`:**

```python
{
    (1, 1): [(1, 2), (2, 1)],
    (1, 2): [(1, 1), (2, 2)],
    (2, 1): [(2, 2), (1, 1), (3, 1)],
    (2, 2): [(2, 1), (1, 2), (3, 2)],
    (3, 1): [(3, 2), (2, 1)],
    (3, 2): [(3, 1), (2, 2)]
}
```

#### Mongolian Tent Graph

Generated by `create_mongolian_tent_graph(tent_size)`. This adds an apex vertex `'x'` to a ladder graph.

**Example for `tent_size=2`:**

```python
{
    (1, 1): [(1, 2), (2, 1), 'x'],
    (1, 2): [(1, 1), (2, 2), 'x'],
    (2, 1): [(2, 2), (1, 1), (3, 1)],
    (2, 2): [(2, 1), (1, 2), (3, 2)],
    (3, 1): [(3, 2), (2, 1)],
    (3, 2): [(3, 1), (2, 2)],
    'x': [(1, 1), (1, 2)]
}
```

#### Circulant Graph

Generated by `generate_circulant_graph(n, r)`. Vertices are integers from `0` to `n-1`.

**Example for `n=8`:**

```python
{
    0: [3, 5],
    1: [4, 6],
    2: [5, 7],
    3: [0, 6],
    4: [1, 7],
    5: [0, 2],
    6: [1, 3],
    7: [2, 4]
}
```

## 2. Vertex Labels (Weights)

The integer labels (or weights) assigned to each vertex are stored in a separate dictionary, typically called `vertex_labels`. This structure maps a vertex identifier to its assigned integer label.

The main goal of the solvers is to populate this dictionary.

**Example for the `n=2` ladder graph:**

A possible valid labeling could be:

```python
{
    (1, 1): 1,
    (1, 2): 3,
    (2, 1): 2,
    (2, 2): 5,
    (3, 1): 4,
    (3, 2): 6
}
```

## 3. Edge Weights

Edge weights are not stored in a persistent data structure. They are **calculated dynamically** during the solving process and tracked temporarily to ensure the core condition of the problem: that all edge weights are unique.

An edge's weight is simply the sum of the labels of its two endpoints. The solvers track the weights they have already used in one of two ways:

1.  **A `set`**: Used by the `BranchAndBoundSolver` to store the numerical values of the weights encountered so far.
2.  **A Boolean Array / Bitmask (`used_weights`)**: A more memory-efficient method used by the backtracking and greedy solvers. The *index* of the array represents the edge weight, and the value (`True`/`False`) indicates if it has been used.

### Example of Edge Weight Tracking

Let's trace how weights are tracked for the `n=2` ladder graph. Assume we have labeled three vertices:
- `vertex_labels[(1, 1)] = 1`
- `vertex_labels[(2, 1)] = 2`
- `vertex_labels[(1, 2)] = 3`

The existing edges between these labeled vertices are `((1, 1), (2, 1))` and `((1, 1), (1, 2))`. The resulting edge weights are `1 + 2 = 3` and `1 + 3 = 4`.

Here is how the two tracking methods would store this state:

#### `set` Example

The `used_edge_weights` set simply contains the numerical weight values.

```python
used_edge_weights = {3, 4}
```

#### Bitmask (`used_weights`) Example

The bitmask is a list of booleans where the index corresponds to the weight. The indices `3` and `4` would be `True`.

```python
# Index: 0  1  2  3  4  5  6  ...
used_weights = [False, False, False, True, True, False, False, ...]
```