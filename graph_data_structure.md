"""# Graph Data Structure

The graphs in this project are represented using an **adjacency list**. This is implemented as a Python dictionary (`collections.defaultdict(list)`) where:
- Each **key** in the dictionary represents a vertex in the graph.
- The **value** associated with a key is a list of all the vertices adjacent to it.

This structure allows for efficient lookup of a vertex's neighbors.

## Vertex Weights (Labels)

The weights, or labels, assigned to each vertex are stored in a separate dictionary. This data structure, referred to as `vertex_labels` in the `labeling_solver.py` file, maps each vertex to an integer value.

The core task of the solvers is to populate this dictionary such that the sum of labels for any two connected vertices is unique across the entire graph.

**Example for the `n=2` ladder graph:**

A possible valid labeling for this graph could be:

```python
{
    (1, 1): 1,
    (1, 2): 3,
    (2, 1): 2,
    (2, 2): 5,
    (3, 1): 4,
    (3, 2): 6
}
```

In this example, the edge connecting `(1, 1)` and `(1, 2)` has a weight of `1 + 3 = 4`. The edge connecting `(1, 1)` and `(2, 1)` has a weight of `1 + 2 = 3`. The solver ensures all such edge weights are unique.

## Edge Weights

Edge weights are not stored in a persistent data structure. They are **calculated dynamically** during the solving process and tracked temporarily to ensure uniqueness.

An edge's weight is the sum of the labels of its two endpoints. The solvers then store these calculated weight values in one of two ways:

1.  **A `set`**: A simple set can be used to store the numerical values of the weights encountered so far. This method is used in the `BranchAndBoundSolver`.
2.  **A Boolean Array / Bitmask (`used_weights`)**: This is a more memory-efficient method used by the core backtracking and greedy solvers. It's a list or `bitarray` where the **index** represents the edge weight. If `used_weights[15]` is `True`, it means an edge with weight 15 already exists in the graph.

This on-the-fly calculation and temporary tracking is central to the validation and backtracking logic of the solvers.

### Example of Edge Weight Tracking

Let's trace how the weights are tracked for the `n=2` ladder graph. Assume we have labeled three vertices:
- `vertex_labels[(1, 1)] = 1`
- `vertex_labels[(2, 1)] = 2`
- `vertex_labels[(1, 2)] = 3`

The existing edges between these labeled vertices are `((1, 1), (2, 1))` and `((1, 1), (1, 2))`.
- The weight for edge `((1, 1), (2, 1))` is `1 + 2 = 3`.
- The weight for edge `((1, 1), (1, 2))` is `1 + 3 = 4`.

Here is how the two tracking methods would store this state:

#### 1. `set` Example

The `used_edge_weights` set simply contains the weight values that have been seen.

```python
used_edge_weights = {3, 4}
```

When the solver considers adding a new edge, it calculates the new weight and checks if that value is already `in` the set.

#### 2. Bitmask (`used_weights`) Example

The bitmask is a list of booleans, initialized to a size that can hold the maximum possible edge weight (e.g., `2 * k_max + 1`). If `k_max` was 6, the list would have a size of 13. The indices `3` and `4` would be set to `True`.

```python
# Index: 0  1  2  3  4  5  6  7  8  9 10 11 12
used_weights = [F, F, F, T, T, F, F, F, F, F, F, F, F]
```

When the solver considers a new edge, it calculates its weight, and uses that weight as an *index* to check the list. This is often faster than a set lookup for the integer ranges involved in this problem.

## Graph Examples

Here are examples of the data structure for each type of graph generated in `src/graph_generator.py`.

### 1. Ladder Graph

Generated by `generate_ladder_graph(n)`.

**Example for `n=2` (a ladder graph with 2 rungs):**

The vertices are represented as tuples `(row, column)`.

```python
{
    (1, 1): [(1, 2), (2, 1)],
    (1, 2): [(1, 1), (2, 2)],
    (2, 1): [(2, 2), (1, 1), (3, 1)],
    (2, 2): [(2, 1), (1, 2), (3, 2)],
    (3, 1): [(3, 2), (2, 1)],
    (3, 2): [(3, 1), (2, 2)]
}
```

### 2. Mongolian Tent Graph

Generated by `create_mongolian_tent_graph(tent_size)`. This graph is a ladder graph with an additional apex vertex connected to all vertices in the top row.

**Example for `tent_size=2`:**

This builds upon the `n=2` ladder graph.

```python
{
    (1, 1): [(1, 2), (2, 1), 'x'],
    (1, 2): [(1, 1), (2, 2), 'x'],
    (2, 1): [(2, 2), (1, 1), (3, 1)],
    (2, 2): [(2, 1), (1, 2), (3, 2)],
    (3, 1): [(3, 2), (2, 1)],
    (3, 2): [(3, 1), (2, 2)],
    'x': [(1, 1), (1, 2)]
}
```

### 3. Circulant Graph

Generated by `generate_circulant_graph(n, r)`. The vertices are integers from `0` to `n-1`. The generator creates a complete circulant graph `K_n` and then removes edges corresponding to generators `s=1, 2, n/2`.

**Example for `n=6`:**

The initial complete graph `K_6` has edges for `s=1, 2, 3`. The function removes these edges. The resulting graph should have degree `n-6`, which is 0 for `n=6`. Let's take `n=8` for a more illustrative example. For `n=8`, the generators to remove are `s=1, 2, 4`.

The complete graph `K_8` has generators `s=1, 2, 3, 4`. After removing `s=1, 2, 4`, only the generator `s=3` remains.

**Example for `n=8`:**

```python
{
    0: [3, 5],
    1: [4, 6],
    2: [5, 7],
    3: [0, 6],
    4: [1, 7],
    5: [0, 2],
    6: [1, 3],
    7: [2, 4]
}
```""
